package pl.saramak.concurent.example;

import com.google.common.base.Function;
import com.google.common.util.concurrent.*;
import lombok.extern.slf4j.Slf4j;
import org.fest.assertions.Assertions;
import org.junit.Test;

import java.util.concurrent.*;

import static java.lang.Thread.sleep;
import static org.fest.assertions.Assertions.assertThat;


/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'saramakm' at '9/5/15 3:46 PM' with Gradle 2.6
 *
 * @author saramakm, @date 9/5/15 3:46 PM
 */
@Slf4j
public class FutureTest {
    @Test
    public void testImmediateFuture() {
        ListenableFuture<String> future = Futures.immediateFuture("Mario");
        Exception exception = null;
        assertThat(future.isDone());
        try {
            assertThat(future.get()).isEqualTo("Mario");
        } catch (InterruptedException e) {
            exception = e;
        } catch (ExecutionException e) {
            exception = e;
        }
        assertThat(exception).isNull();
    }

    @Test(timeout = 5000)
    public void testThreadPoolGuava() {
        //GIVEN thread pool with tasks
        final ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
        log.info("Start work");
        final String testString = "Mario";
        final ListenableFuture<String> task = service.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                //I do so much :)
                sleep(1000);
                return "Mario";
            }
        });
        task.addListener(new Runnable() {
            @Override
            public void run() {
                try {
                    log.info("Runnable success " + task.get());
                    assertThat(task.get()).isEqualTo("Mario");
                } catch (InterruptedException e) {
                    log.error("ignore", e);
                } catch (ExecutionException e) {
                    log.error("ignore", e);
                }
            }

        }, MoreExecutors.sameThreadExecutor());
        Futures.addCallback(task, new FutureCallback<String>() {
                    @Override
                    public void onSuccess(final String result) {
                        log.info("result onSuccess " + result);
                    }

                    @Override
                    public void onFailure(final Throwable t) {
                        log.info("result onFailure ", t);
                    }
                }

        );
        ListenableFuture<Integer> task2 = Futures.transform(task, new Function<String, Integer>() {
            @Override
            public Integer apply(String input) {
                return input.length();
            }
        });
        Integer lenght = null;
        try {
            lenght = task2.get(1010, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            log.error("ignore", e);
        } catch (ExecutionException e) {
            log.error("ignore", e);
        } catch (TimeoutException e) {
            log.error("ignore", e);
        }
        log.info("lenght" + lenght);
        assertThat(lenght).isEqualTo(5);
        waits(3);
    }

    private void waits(int ts) {
        synchronized (this) {
            try {
                wait(ts * 1000);
            } catch (InterruptedException e) {
                log.error("ignore", e);
            }
        }
    }
}
